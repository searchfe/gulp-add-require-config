"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = require("path");
var fs_1 = require("fs");
var fs_extra_1 = require("fs-extra");
var hash_1 = require("./hash");
var Cache = /** @class */ (function () {
    function Cache() {
    }
    Cache.prototype.setKey = function (key) {
        // 工作路径
        this.dir = path_1.resolve(__dirname, '.cache', key);
        fs_extra_1.mkdirpSync(this.dir);
    };
    Cache.prototype.getPass = function (file) {
        var cacheDir = this.dir + '/' + hash_1.getName(file);
        if (fs_1.existsSync(cacheDir + '.pass')) {
            if (fs_1.existsSync(cacheDir + '.link')) {
                var info = fs_1.readFileSync(cacheDir + '.info').toString().split('\n');
                file.path = info[2] || file.path;
                // console.log("完成重定向A");
            }
            return file;
        }
    };
    Cache.prototype.getCache = function (file) {
        var cacheDir = this.dir + '/' + hash_1.getName(file);
        if (!fs_1.existsSync(cacheDir + '.cache')) {
            return;
        }
        if (this.checkDeps(cacheDir) === false) {
            return;
        }
        file.contents = fs_1.readFileSync(cacheDir + '.cache');
        if (fs_1.existsSync(cacheDir + '.link')) {
            var info = fs_1.readFileSync(cacheDir + '.info').toString().split('\n');
            file.path = info[2] || file.path;
            // console.log("完成重定向B");
        }
        return file;
    };
    Cache.prototype.checkDeps = function (cacheDir) {
        if (!fs_1.existsSync(cacheDir + '.deps')) {
            return true;
        }
        var diff = false;
        fs_1.readFileSync(cacheDir + '.deps').toString().split('\n').forEach(function (line) {
            var arr = line.split('\t');
            if (diff === false && arr.length === 2) {
                if (fs_1.existsSync(arr[0]) && fs_1.statSync(arr[0]).mtimeMs.toString() === arr[1]) {
                }
                else {
                    diff = true;
                }
            }
        });
        if (diff) {
            console.log('DDDDDDIF+++++++', diff, cacheDir);
            console.log('DDDDDDIF-------', diff, fs_1.readFileSync(cacheDir + '.info').toString());
        }
        return !diff;
    };
    Cache.prototype.passCache = function (file, oldPath) {
        if (file && file.stat && file.stat.mtimeMs) {
            var cacheDir = this.dir + '/' + hash_1.getName(file, oldPath);
            fs_1.writeFileSync(cacheDir + '.pass', '');
            fs_1.writeFileSync(cacheDir + '.info', oldPath + "\n" + file.stat.mtimeMs + "\n" + file.path + "\n");
            if (oldPath !== file.path) {
                fs_1.writeFileSync(cacheDir + '.link', '');
            }
        }
    };
    Cache.prototype.saveCache = function (file, oldPath) {
        if (file && file.stat && file.stat.mtimeMs) {
            var cacheDir = this.dir + '/' + hash_1.getName(file, oldPath);
            if (file.depFiles && file.depFiles.length) {
                var error_1 = false;
                var depinfo_1 = '';
                file.depFiles.forEach(function (dep) {
                    if (fs_1.existsSync(dep)) {
                        depinfo_1 += dep + "\t" + fs_1.statSync(dep).mtimeMs + '\n';
                    }
                    else {
                        error_1 = true;
                        console.warn("WATIN: " + dep + " does not exist!");
                        return;
                    }
                });
                if (error_1) {
                    return;
                }
                fs_1.writeFileSync(cacheDir + '.deps', depinfo_1);
            }
            fs_1.writeFileSync(cacheDir + '.cache', file.contents);
            fs_1.writeFileSync(cacheDir + '.info', oldPath + "\n" + file.stat.mtimeMs + "\n" + file.path + "\n");
            if (oldPath !== file.path) {
                fs_1.writeFileSync(cacheDir + '.link', '');
            }
        }
    };
    Cache.prototype.proxy = function (t) {
        var _this = this;
        if (process.env.build_cache === "open") {
            return function (file, enc, callback) {
                var oldPath = file.path;
                var passFile = _this.getPass(file);
                if (passFile) {
                    // console.log('pass');
                    // 上次无处理 且mtime不变
                    callback(null, passFile);
                    return;
                }
                var newFile = _this.getCache(file);
                var oldBuffer = file.contents;
                if (newFile) {
                    // console.log('use cache');
                    callback(null, newFile);
                }
                else {
                    // t是业务的回调
                    // callback是pipe的回调
                    t(file, enc, function (buffer, nfile) {
                        // 业务进行了回调
                        // if (nfile.path === oldPath) {
                        if (oldBuffer === nfile.contents && !nfile.depFiles) {
                            // 没有变化 标记无处理
                            console.log('save pass');
                            _this.passCache(nfile, oldPath);
                        }
                        else {
                            console.log('save cache');
                            _this.saveCache(nfile, oldPath);
                        }
                        callback(null, nfile);
                        // } else {
                        // }
                    });
                }
            };
        }
        else {
            return t;
        }
    };
    Cache.clearAll = function () {
        fs_extra_1.removeSync(path_1.resolve(__dirname, '.cache'));
    };
    return Cache;
}());
exports.Cache = Cache;
/**
 *     传递
 *     改变
 *     不callback
 *     旁路
 */
